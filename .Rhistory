library(R.matlab)
library(tidyverse); library(reshape2)
setwd("C:/Users/kaank/OneDrive/Belgeler/GitHub/sch_pe/")
alpha_mat <- readMat("./results/models/alpha_matrix.mat")
subj_table <- read.csv("./data/raw/subjects_list.csv")
subj_table <- subset(subj_table, !(subj %in% c(9, 44)))
dat <- readMat("./data/processed/normalized_pe_array2.mat")
convert_to_long <- function(dat, group,subj_table, exclude=TRUE) {
# Extract PE matrix (first 60 columns) and group information (column 61)
if (exclude) dat <- dat[-c(9, 44), ]
pe_mat <- dat[,1:60]
group <- group
task <- factor(rep(1:3, each = 20))  # Assuming 3 tasks with 20 trials each
sex <- factor(ifelse(subj_table$sex, "M", "F"))
age <- as.numeric(subj_table$age)
doi <- as.numeric(subj_table$DoI)
# Convert PE matrix to a data frame
pe_df <- as.data.frame(pe_mat)
# Add Subject IDs
pe_df$Subject <- seq_len(nrow(pe_mat))  # Assign unique IDs to subjects
# Reshape to long format
long_pe <- melt(pe_df, id.vars = "Subject", variable.name = "Trial", value.name = "PE")
# Convert Trial variable to numeric
#long_pe$Trial <- as.numeric(gsub("V", "", long_pe$Trial))  # Remove "V" prefix if needed
# Add Group information (repeat for each trial)
long_pe$Group <- rep(group, each = ncol(pe_mat))
# Add Task information (repeat for each subject)
long_pe$Task <- rep(task, times = nrow(pe_mat))
# Add Sex information (repeat for each trial)
long_pe$Sex <- rep(sex, each = ncol(pe_mat))
# Add Age information (repeat for each trial)
long_pe$Age <- rep(age, each = ncol(pe_mat))
# Add DoI information (repeat for each trial)
long_pe$DoI <- rep(doi, each = ncol(pe_mat))
return(long_pe)
}
alpha_long <- convert_to_long(alpha_mat$alpha.matrix, dat$merged.matrix[-c(9, 44),61], subj_table, TRUE)
alpha_long$PE_logit <- qlogis(alpha_long$PE)  # qlogis = logit function
# Frequentist statistics
library(glmmTMB)
# Ensure PE is strictly between 0 and 1
alpha_long$PE <- pmin(pmax(alpha_long$PE, 1e-6), 1 - 1e-6)
# Avoid 0 or 1 exactly
alpha_long$PE_adj <- pmin(pmax(alpha_long$PE, 1e-6), 1 - 1e-6)
# Convert Group and Task to factors if not already
alpha_long$Group <- factor(alpha_long$Group, labels = c("HC", "SZ"))
alpha_long$Task <- factor(alpha_long$Task)
# Fit the Beta model
fit_glmm <- glmmTMB(
PE ~ Task + Group * Sex + DoI + (1 | Subject),
data = alpha_long,
family = gaussian(link = "logit")
)
summary(fit_glmm)
### Model Diagnostics ####
library(DHARMa)
# Simulate residuals
sim_res <- simulateResiduals(fit_glmm)
# Plot residual diagnostics
plot(sim_res)
library(performance)
icc(fit_glmm)
#### Checking model multicollinearity
library(car)
vif(fit_glmm)
# Fit the Beta model
fit_glmm <- glmer(
PE ~ Task + Group * Sex + DoI + (1 | Subject),
data = alpha_long,
family = gaussian(link = "logit")
)
library(lme4)
# Fit the Beta model
fit_glmm <- glmer(
PE ~ Task + Group * Sex + DoI + (1 | Subject),
data = alpha_long,
family = gaussian(link = "logit")
)
summary(fit_glmm)
alpha_long$DoI_z <- scale(alpha_long$DoI)  # mean=0, sd=1
# Fit the Beta model
fit_glmm <- glmer(
PE ~ Task + Group * Sex + DoI_z + (1 | Subject),
data = alpha_long,
family = gaussian(link = "logit")
)
summary(fit_glmm)
#### Checking model multicollinearity
library(car)
vif(fit_glmm)
library(performance)
icc(fit_glmm)
# Fit the Beta model
fit_glmm <- glmer(
PE ~ Task + Group * Sex + DoI_z + (1 | Subject),
data = alpha_long,
family = gaussian(link = "logit")
)
summary(fit_glmm)
### Model Diagnostics ####
library(DHARMa)
# Simulate residuals
sim_res <- simulateResiduals(fit_glmm)
# Plot residual diagnostics
plot(sim_res)
fit_glmm <- glmmTMB(
PE ~ Task + Group * Sex + DoI_z + (1 | Subject),
data = alpha_long,
family = gaussian(link = "logit")
)
summary(fit_glmm)
### Model Diagnostics ####
library(DHARMa)
# Simulate residuals
sim_res <- simulateResiduals(fit_glmm)
# Plot residual diagnostics
plot(sim_res)
library(performance)
icc(fit_glmm)
library(R.matlab); library(tidyverse); library(reshape2)
#setwd("/Users/kaankeskin/projects/sch_pe/")
# Microsoft
setwd("C:/Users/kaank/OneDrive/Belgeler/GitHub/sch_pe/")
#
dat <- list(readMat("./data/processed/normalized_pe_array2.mat"), # Cemre RW PE
readMat("./data/processed/x2_array.mat"), # HGF X2
readMat("./data/processed/x3_array.mat"), # HGF X3
readMat("./data/processed/x2_pe_array.mat"), # HGF low level PE
readMat("./data/processed/x3_pe_array.mat"), # HGF high level PE
readMat("./data/processed/alfa2_array.mat"), # learning rate level 2
readMat("./data/processed/alfa3_array.mat"), # learning rate level 3
readMat("./data/processed/rw_pe.mat") # RW model PE from TAPAS
)
subj_table <- read.csv("./data/raw/subjects_list.csv")
subj_table <- subset(subj_table, !(subj %in% c(9, 44)))
#dat <- readMat("/Users/kaankeskin/projects/sch_pe/data/processed/normalized_pe_array.mat")
convert_to_long <- function(dat, subj_table, exclude=TRUE) {
# Extract PE matrix (first 60 columns) and group information (column 61)
if (exclude) dat$merged.matrix <- dat$merged.matrix[-c(9, 44), ]
pe_mat <- dat$merged.matrix[,1:60]
group <- factor(ifelse(dat$merged.matrix[,61], "sz", "hc"))
task <- factor(rep(1:3, each = 20))  # Assuming 3 tasks with 20 trials each
sex <- factor(ifelse(subj_table$sex, "M", "F"))
age <- as.numeric(subj_table$age)
doi <- as.numeric(subj_table$DoI)
# Convert PE matrix to a data frame
pe_df <- as.data.frame(pe_mat)
# Add Subject IDs
pe_df$Subject <- seq_len(nrow(pe_mat))  # Assign unique IDs to subjects
# Reshape to long format
long_pe <- melt(pe_df, id.vars = "Subject", variable.name = "Trial", value.name = "PE")
# Convert Trial variable to numeric
#long_pe$Trial <- as.numeric(gsub("V", "", long_pe$Trial))  # Remove "V" prefix if needed
# Add Group information (repeat for each trial)
long_pe$Group <- rep(group, each = ncol(pe_mat))
# Add Task information (repeat for each subject)
long_pe$Task <- rep(task, times = nrow(pe_mat))
# Add Sex information (repeat for each trial)
long_pe$Sex <- rep(sex, each = ncol(pe_mat))
# Add Age information (repeat for each trial)
long_pe$Age <- rep(age, each = ncol(pe_mat))
# Add DoI information (repeat for each trial)
long_pe$DoI <- rep(doi, each = ncol(pe_mat))
return(long_pe)
}
# Usage
long_pe_list <- lapply(dat, convert_to_long, subj_table = subj_table)
long_pe_list[[1]]$logPE <- log(long_pe_list[[1]]$PE_shifted)
# Usage
long_pe_list <- lapply(dat, convert_to_long, subj_table = subj_table)
library(lme4)
library(lmerTest)
# Gamma modelling is more appropriate due to skewed nature of the data
long_pe_list[[1]]$PE_shifted <- long_pe_list[[1]]$PE + abs(min(long_pe_list[[1]]$PE)) + 0.25
long_pe_list[[1]]$logPE <- log(long_pe_list[[1]]$PE_shifted)
lognormal_model <- lmer(logPE ~ Group * Sex + Task + (1 | Subject) + DoI, data = long_pe_list[[1]])
library(DHARMa)
# Simulate residuals
sim_res <- simulateResiduals(lognormal_model)
# Plot residual diagnostics
plot(sim_res)
library(DHARMa)
# Simulate residuals
sim_res <- simulateResiduals(lognormal_model)
# Plot residual diagnostics
plot(sim_res)
lognormal_model <- glmmTMB(logPE ~ Group * Sex + Task + (1 | Subject) + DoI, data = long_pe_list[[1]])
summary(lognormal_model)
library(DHARMa)
# Simulate residuals
sim_res <- simulateResiduals(lognormal_model)
# Plot residual diagnostics
plot(sim_res)
long_pe_list[[1]]$DoI_z <- scale(long_pe_list[[1]]$DoI)
lognormal_model <- glmmTMB(logPE ~ Group * Sex + Task + (1 | Subject) + DoI_z, data = long_pe_list[[1]])
summary(lognormal_model)
### Model Diagnostics ####
library(DHARMa)
# Simulate residuals
sim_res <- simulateResiduals(lognormal_model)
# Plot residual diagnostics
plot(sim_res)
lognormal_model <- glmmTMB(logPE ~ Group * Sex + Task + (1 | Subject) + DoI, data = long_pe_list[[1]])
summary(lognormal_model)
fit_glmm <- glmmTMB(
PE ~ Task + Group * Sex + DoI_z + (1 | Subject),
data = alpha_long,
family = gaussian(link = "logit")
)
summary(fit_glmm)
### Model Diagnostics ####
library(DHARMa)
# Simulate residuals
sim_res <- simulateResiduals(fit_glmm)
# Plot residual diagnostics
plot(sim_res)
library(performance)
icc(fit_glmm)
#### Checking model multicollinearity
library(car)
vif(fit_glmm)
lognormal_model <- glmmTMB(logPE ~ Group * Sex + Task + (1 | Subject) + DoI_z, data = long_pe_list[[1]])
summary(lognormal_model)
library(car)
vif(lognormal_model)
library(glmmTMB)
fit_tmb <- glmmTMB(
PE ~ Task + Group * Sex + DoI_z + (1 | Subject),
data = alpha_long,
family = beta_family(link = "logit")
)
fixed_formula <- formula(fit_glmm)[[3]]  # Right-hand side only
fixed_formula
fixed_model <- lm(as.formula(paste("PE ~", deparse(fixed_formula))), data = alpha_long)
library(car)
vif(fixed_model)
vif(fixed_model, type = "predictor")  # Each variable treated separately
fixed_model <- lm(PE ~ Task + Group * Sex + DoI_z, data = alpha_long)
vif(fixed_model)  # Or vif(fixed_model, type = "predictor")
vif(fixed_model, type="predictor")
# Fit the Beta model
fit_glmm <- glmmTMB(
PE ~ Task + Group * Sex + DoI_z + (1 | Subject),
data = alpha_long,
family = gaussian(link = "logit")
)
summary(fit_glmm)
### Model Diagnostics ####
library(DHARMa)
# Simulate residuals
sim_res <- simulateResiduals(fit_glmm)
# Plot residual diagnostics
plot(sim_res)
library(performance)
icc(fit_glmm)
# glmmTMB stores this in a compiled C++ object that car::vif() cannot parse.
library(car)
fixed_model <- lm(PE ~ Task + Group * Sex + DoI_z, data = alpha_long)
vif(fixed_model, type="predictor")  # Or vif(fixed_model, type = "predictor")
custom_labels <- c(
"GroupSZ" = "SZ vs. HC",
"SexM" = "M vs. F",
"GroupSZ:SexM" = "Group × Sex",
"Task2" = "Phase 2 vs. Phase 1",
"Task3" = "Phase 3 vs. Phase 1",
"DoI_z" = "Illness Duration"
)
plot_prediction_effects(fit_glmm, exclude_intercept = TRUE, custom_labels = custom_labels, TITLE = " (Logit Gaussian GLMM)")
source("~/GitHub/sch_pe/external/R/plot_prediction_effects.R", echo=TRUE)
custom_labels <- c(
"GroupSZ" = "SZ vs. HC",
"SexM" = "M vs. F",
"GroupSZ:SexM" = "Group × Sex",
"Task2" = "Phase 2 vs. Phase 1",
"Task3" = "Phase 3 vs. Phase 1",
"DoI_z" = "Illness Duration"
)
plot_prediction_effects(fit_glmm, exclude_intercept = TRUE, custom_labels = custom_labels, TITLE = " (Logit Gaussian GLMM)")
glmmTMB()
fit_glmm
summary(fit_glmm)
custom_labels <- c(
"GroupSZ" = "SZ vs. HC",
"Task2" = "Phase 2 vs. Phase 1",
"Task3" = "Phase 3 vs. Phase 1",
"SexM" = "M vs. F",
"GroupSZ:SexM" = "Group × Sex",
"DoI_z" = "Illness Duration"
)
plot_prediction_effects(fit_glmm, exclude_intercept = TRUE, custom_labels = custom_labels, TITLE = " (Logit Gaussian GLMM)")
custom_labels <- c(
"GroupSZ" = "SZ vs. HC",
"Task2" = "Phase 2 vs. Phase 1",
"Task3" = "Phase 3 vs. Phase 1",
"SexM" = "M vs. F",
"GroupSZ:SexM" = "Group x Sex",
"DoI_z" = "Illness Duration"
)
plot_prediction_effects(fit_glmm, exclude_intercept = TRUE, custom_labels = custom_labels, TITLE = " (Logit Gaussian GLMM)")
source("~/GitHub/sch_pe/external/R/plot_prediction_effects.R", echo=TRUE)
plot_prediction_effects(fit_glmm, exclude_intercept = TRUE, custom_labels = custom_labels,
TITLE = "Prediction Error Effects with 95% CI (Logit Gaussian GLMM)",
XLAB = "Multiplicative Effect on Raw Learning Rate")
plot_prediction_effects(fit_glmm, exclude_intercept = TRUE, custom_labels = custom_labels,
TITLE = "Learning Rate Effects with 95% CI (Logit Gaussian GLMM)",
XLAB = "Multiplicative Effect on Raw Learning Rate")
library(DHARMa)
# Simulate residuals
sim_res <- simulateResiduals(fit_glmm)
# Plot residual diagnostics
plot(sim_res)
