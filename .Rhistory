ggplot(sim_uni,aes( x = group, y = value)) +
geom_boxplot() +
theme_minimal()
array1<-c(39,33,14,32,10,50,47,30,34,50,37,42,47,44,50,33,46,28,46,29,49,33,54,31,37,35
)
array2 <- c(48,34,51,35,25,25,46,22,8,38,52,28,10,37,27,24)
kruskal.test(array1,array2)
shapiro.test(array1)
shapiro.test(array2)
t_test_result <- t.test(array1, array2, var.equal = FALSE)
print(t_test_result)
library(NeuroMyelFC)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
source_folder = "C:/Users/kaank/OneDrive/Belgeler/GitHub/MYELIN_2/"
# Set the Python path (adjust the path to your Python executable)
# Use the specific Python executable
# HAS TO BE 3.11
use_python("C:/Users/kaan/AppData/Local/Programs/Python/Python311/python.exe")
library(reticulate)
#source_folder = "/Users/kaankeskin/projects/MYELIN_2/"
source_folder = "C:/Users/kaank/OneDrive/Belgeler/GitHub/MYELIN_2/"
# Set the Python path (adjust the path to your Python executable)
# Use the specific Python executable
# HAS TO BE 3.11
use_python("C:/Users/kaan/AppData/Local/Programs/Python/Python311/python.exe")
source_folder = "C:/Users/kaank/OneDrive/Belgeler/GitHub/MYELIN_2/"
source_folder = "C:/Users/kaank/OneDrive/Belgeler/GitHub/MYELIN_2/"
use_python("C:/Users/kaank/miniconda3/envs/multgroup/python.exe")
np <- import("numpy")
merge_matrices <- function(array) {
# Initialize empty matrices to store the merged results
merged_acw_static_firing_matrix <- NULL
merged_acw_dynamic_firing_matrix <- NULL
merged_gscorr_fmri_matrix <- NULL
merged_gscorr_firing_matrix <- NULL
# Loop through each element in the list and row bind the matrices
for (i in seq_along(array)) {
merged_acw_static_firing_matrix <- rbind(merged_acw_static_firing_matrix, array[[i]]$acw_static_firing_matrix)
merged_acw_dynamic_firing_matrix <- rbind(merged_acw_dynamic_firing_matrix, array[[i]]$acw_dynamic_firing_matrix)
merged_gscorr_fmri_matrix <- rbind(merged_gscorr_fmri_matrix, array[[i]]$gscorr_fmri_matrix)
merged_gscorr_firing_matrix <- rbind(merged_gscorr_firing_matrix, array[[i]]$gscorr_firing_matrix)
}
# Return a list of merged matrices
return(list(
acw_static_firing_matrix = merged_acw_static_firing_matrix,
acw_dynamic_firing_matrix = merged_acw_dynamic_firing_matrix,
gscorr_fmri_matrix = merged_gscorr_fmri_matrix,
gscorr_firing_matrix = merged_gscorr_firing_matrix
))
}
no_topo <- merge_matrices(np$load(paste0(source_folder,"DATA/notopo_v3.npy"),allow_pickle = TRUE))
level_list = list()
ylab_list = list()
parts=c("acw_dynamic_firing_matrix")
level_list[[parts[1]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
ylab_list[[parts[1]]] = c("Sliding Window ACW")
notopo_sim_ACW <- calculate_prs(no_topo, parts = parts,levels=level_list,y_labels = ylab_list,textsize=6,sign_size=4,ast_size = 6,title = "Fixed Recurrence \n Fixed Excitation", ylab_size= 12, method = "rowMeans")
notopo_sim_ACW
notopo_sim_ACW + theme(
axis.text.x = element_text(face = "bold"),
axis.text.y = element_text(face = "bold")
)
library(tidyverse)
notopo_sim_ACW + theme(
axis.text.x = element_text(face = "bold"),
axis.text.y = element_text(face = "bold")
)
notopo_sim_ACW$interaction_plots[[1]] + theme(
axis.text.x = element_text(face = "bold"),
axis.text.y = element_text(face = "bold")
)
notopo_sim_ACW$interaction_plots[[1]]
notopo_sim_ACW$interaction_plots[[1]] + theme(
axis.text.x = element_text(face = "bold"),
axis.text.y = element_text(face = "bold")
)
notopo_sim_ACW$interaction_plots[[1]]
source(NeuromyelFC)
no_topo <- merge_matrices(np$load(paste0(source_folder,"DATA/notopo_v3.npy"),allow_pickle = TRUE))
level_list = list()
ylab_list = list()
parts=c("acw_dynamic_firing_matrix")
level_list[[parts[1]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
ylab_list[[parts[1]]] = c("Sliding Window ACW")
notopo_sim_ACW <- calculate_prs(no_topo, parts = parts,levels=level_list,y_labels = ylab_list,textsize=6,sign_size=4,ast_size = 6,title = "Fixed Recurrence \n Fixed Excitation", ylab_size= 12, method = "rowMeans")
notopo_sim_ACW$interaction_plots[[1]]
notopo_sim_ACW$interaction_plots[[1]]
library(NeuroMyelFC)
no_topo <- merge_matrices(np$load(paste0(source_folder,"DATA/notopo_v3.npy"),allow_pickle = TRUE))
level_list = list()
ylab_list = list()
parts=c("acw_dynamic_firing_matrix")
level_list[[parts[1]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
ylab_list[[parts[1]]] = c("Sliding Window ACW")
notopo_sim_ACW <- calculate_prs(no_topo, parts = parts,levels=level_list,y_labels = ylab_list,textsize=6,sign_size=4,ast_size = 6,title = "Fixed Recurrence \n Fixed Excitation", ylab_size= 12, method = "rowMeans")
notopo_sim_ACW$interaction_plots[[1]]
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
source_folder = "C:/Users/kaank/OneDrive/Belgeler/GitHub/MYELIN_2/"
use_python("C:/Users/kaank/miniconda3/envs/multgroup/python.exe")
library(reticulate)
source_folder = "C:/Users/kaank/OneDrive/Belgeler/GitHub/MYELIN_2/"
use_python("C:/Users/kaank/miniconda3/envs/multgroup/python.exe")
#use_python("/opt/anaconda3/envs/neurolib_env/bin/python")
np <- import("numpy")
merge_matrices <- function(array) {
# Initialize empty matrices to store the merged results
merged_acw_static_firing_matrix <- NULL
merged_acw_dynamic_firing_matrix <- NULL
merged_gscorr_fmri_matrix <- NULL
merged_gscorr_firing_matrix <- NULL
# Loop through each element in the list and row bind the matrices
for (i in seq_along(array)) {
merged_acw_static_firing_matrix <- rbind(merged_acw_static_firing_matrix, array[[i]]$acw_static_firing_matrix)
merged_acw_dynamic_firing_matrix <- rbind(merged_acw_dynamic_firing_matrix, array[[i]]$acw_dynamic_firing_matrix)
merged_gscorr_fmri_matrix <- rbind(merged_gscorr_fmri_matrix, array[[i]]$gscorr_fmri_matrix)
merged_gscorr_firing_matrix <- rbind(merged_gscorr_firing_matrix, array[[i]]$gscorr_firing_matrix)
}
# Return a list of merged matrices
return(list(
acw_static_firing_matrix = merged_acw_static_firing_matrix,
acw_dynamic_firing_matrix = merged_acw_dynamic_firing_matrix,
gscorr_fmri_matrix = merged_gscorr_fmri_matrix,
gscorr_firing_matrix = merged_gscorr_firing_matrix
))
}
no_topo <- merge_matrices(np$load(paste0(source_folder,"DATA/notopo_v3.npy"),allow_pickle = TRUE))
level_list = list()
ylab_list = list()
parts=c("acw_dynamic_firing_matrix")
level_list[[parts[1]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
ylab_list[[parts[1]]] = c("Sliding Window ACW")
notopo_sim_ACW <- calculate_prs(no_topo, parts = parts,levels=level_list,y_labels = ylab_list,textsize=6,sign_size=4,ast_size = 6,title = "Fixed Recurrence \n Fixed Excitation", ylab_size= 12, method = "rowMeans")
library(NeuroMyelFC)
no_topo <- merge_matrices(np$load(paste0(source_folder,"DATA/notopo_v3.npy"),allow_pickle = TRUE))
level_list = list()
ylab_list = list()
parts=c("acw_dynamic_firing_matrix")
level_list[[parts[1]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
ylab_list[[parts[1]]] = c("Sliding Window ACW")
notopo_sim_ACW <- calculate_prs(no_topo, parts = parts,levels=level_list,y_labels = ylab_list,textsize=6,sign_size=4,ast_size = 6,title = "Fixed Recurrence \n Fixed Excitation", ylab_size= 12, method = "rowMeans")
notopo_sim_ACW$interaction_plots
notopo_sim_ACW <- calculate_prs(no_topo, parts = parts,levels=level_list,y_labels = ylab_list,textsize=6,sign_size=4,ast_size = 6,title = "Fixed Recurrence \n Fixed Excitation", ylab_size= 12, method = "rowMeans")
### ONLY BASELINE ####
only_baseline <- merge_matrices(np$load(paste0(source_folder,"DATA/onlybase_v3.npy"),allow_pickle = TRUE))
baseline_sim_ACW <- calculate_prs(only_baseline, parts = parts,levels=level_list,y_labels = ylab_list,textsize=6,sign_size=4,ast_size = 6,title = "Fixed Recurrence \n Topograhical Excitation", ylab_size= 12, method = "rowMeans")
### BASELINE + RECURRENT #####
base_recurrent <- merge_matrices(np$load(paste0(source_folder,"DATA/baserecur_v3.npy"),allow_pickle = TRUE))
base_recur_sim_ACW <- calculate_prs(base_recurrent, parts = parts,levels=level_list,y_labels = ylab_list,textsize=6,sign_size=4,ast_size = 6,title = "Topographical Recurrence \n Topograhical Excitation ", ylab_size= 12, method = "rowMeans")
####
# GSCORR ##
### NO TOPO ###
no_topo<- merge_matrices(np$load(paste0(source_folder,"DATA/notopo_v3.npy"),allow_pickle = TRUE))
level_list = list()
ylab_list = list()
parts=c("gscorr_fmri_matrix", "gscorr_firing_matrix")
level_list[[parts[1]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
level_list[[parts[2]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
ylab_list[[parts[1]]] = c("Balloon GSCORR")
ylab_list[[parts[2]]] = c("Firing rate GSCORR ")
notopo_sim <- calculate_prs(no_topo, parts = parts,levels=level_list,y_labels = ylab_list,textsize=6,sign_size=4,ast_size = 6,title = "Fixed Recurrence \n Fixed Excitation", ylab_size= 12, method = "rowMeans")
### ONLY BASELINE ####
only_baseline <- merge_matrices(np$load(paste0(source_folder,"DATA/onlybase_v3.npy"),allow_pickle = TRUE))
level_list = list()
ylab_list = list()
parts=c("gscorr_fmri_matrix", "gscorr_firing_matrix")
level_list[[parts[1]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
level_list[[parts[2]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
ylab_list[[parts[1]]] = c("Balloon GSCORR")
ylab_list[[parts[2]]] = c("Firing rate GSCORR ")
baseline_sim <- calculate_prs(only_baseline, parts = parts,levels=level_list,y_labels = ylab_list,textsize=6,sign_size=4,ast_size = 6,title = "Fixed Recurrence \n Topograhical Excitation", ylab_size= 12, method = "rowMeans")
### BASELINE + RECURRENT #####
base_recurrent <- merge_matrices(np$load(paste0(source_folder,"DATA/baserecur_v3.npy"),allow_pickle = TRUE))
#base_recurrent$gscorr_firing_matrix <- base_recurrent$gscorr_firing_matrix[1:60,]
level_list = list()
ylab_list = list()
parts=c("gscorr_fmri_matrix", "gscorr_firing_matrix")
level_list[[parts[1]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
level_list[[parts[2]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
ylab_list[[parts[1]]] = c("Balloon GSCORR")
ylab_list[[parts[2]]] = c("Firing rate GSCORR ")
base_recur_sim <- calculate_prs(base_recurrent, parts = parts,levels=level_list,y_labels = ylab_list,textsize=6,sign_size=4,ast_size = 6,title = "Topographical Recurrence \n Topograhical Excitation ", ylab_size= 12, method = "rowMeans")
base_recur_sim$interaction_plots$gscorr_firing_matrix
# Common figure
plotlist = list(
notopo_sim$interaction_plots$gscorr_firing_matrix,
baseline_sim$interaction_plots$gscorr_firing_matrix,
base_recur_sim$interaction_plots$gscorr_firing_matrix,
notopo_sim_ACW$interaction_plots$acw_dynamic_firing_matrix,
baseline_sim_ACW$interaction_plots$acw_dynamic_firing_matrix,
base_recur_sim_ACW$interaction_plots$acw_dynamic_firing_matrix
)
ggpubr::ggarrange(plotlist = plotlist, nrow = 2, ncol = 3
)
ggpubr::ggarrange(plotlist = plotlist, nrow = 2, ncol = 3
)%>% ggpubr::ggexport(filename = paste0(source_folder,"FIGURES/recur_group_v3.png"),height = 800, width = 1200, res= 150)
library(tidyverse)
ggpubr::ggarrange(plotlist = plotlist, nrow = 2, ncol = 3
)%>% ggpubr::ggexport(filename = paste0(source_folder,"FIGURES/recur_group_v3.png"),height = 800, width = 1200, res= 150)
source_folder = "/Users/kaankeskin/projects/MYELIN_2/"
# New figure with results
library(magick)
# Example PNG files
file1 <- paste0(source_folder,"FIGURES/Wilcox.png")
file2 <- paste0(source_folder,"FIGURES/test.png")
file3 <- paste0(source_folder,"FIGURES/empirical.png")
file4 <- paste0(source_folder,"FIGURES/recur_group_v3.png")
# Read the PNG files
image1 <- image_read(file1) %>% image_resize(geometry = "400x")
source_folder = "C:/Users/kaank/OneDrive/Belgeler/GitHub/MYELIN_2/"
# New figure with results
library(magick)
# Example PNG files
file1 <- paste0(source_folder,"FIGURES/Wilcox.png")
file2 <- paste0(source_folder,"FIGURES/test.png")
file3 <- paste0(source_folder,"FIGURES/empirical.png")
file4 <- paste0(source_folder,"FIGURES/recur_group_v3.png")
# Read the PNG files
image1 <- image_read(file1) %>% image_resize(geometry = "400x")
image2 <- image_read(file2) %>% image_resize(geometry = "800x")
image3 <- image_read(file3) %>% image_resize(geometry = "1200x")
image4 <- image_read(file4) %>% image_resize(geometry = "1200x")
image_w <- image_blank(width=1200, height = 200, color = "white")
image1_2 <- image_append(c(image1,image2), stack = FALSE)
fig_5_merged <- image_append(c(image3,image_w, image4), stack = TRUE)
fig_5_merged
source_folder = "C:/Users/kaank/OneDrive/Belgeler/GitHub/MYELIN_2/"
# New figure with results
library(magick)
# Example PNG files
file1 <- paste0(source_folder,"FIGURES/Wilcox.png")
file2 <- paste0(source_folder,"FIGURES/test.png")
file3 <- paste0(source_folder,"FIGURES/empirical.png")
file4 <- paste0(source_folder,"FIGURES/recur_group_v3.png")
# Read the PNG files
image1 <- image_read(file1) %>% image_resize(geometry = "400x")
image2 <- image_read(file2) %>% image_resize(geometry = "800x")
image3 <- image_read(file3) %>% image_resize(geometry = "1200x")
image4 <- image_read(file4) %>% image_resize(geometry = "1200x")
image_w <- image_blank(width=1200, height = 200, color = "white")
image1_2 <- image_append(c(image1,image2), stack = FALSE)
fig_5_merged <- image_append(c(image3,image_w, image4), stack = TRUE)
fig_5_merged
png(paste0(source_folder,"FIGURES/fig_5_new3.png"), width = 1200, height = 1524, res = 150)
plot(fig_5_merged)
text(x = 0, y = 1600, labels = "A", xpd = NA, cex=1.5, font=2)
text(x = 0, y = 1300, labels = "B", xpd = NA, cex=1.5, font=2)
text(x = 550, y = 1380, labels = "Empirical Results", xpd = NA, cex=1.5, font=1)
text(x = 550, y = 900, labels = "Simulation Results", xpd = NA, cex=1.5, font=1)
text(x = 0, y = 770, labels = "C", xpd = NA, cex=1.5, font=2)
text(x = 0, y = 770, labels = "C", xpd = NA, cex=1.5, font=2)
text(x = 0, y = 370, labels = "D", xpd = NA, cex=1.5, font=2)
dev.off()
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
library(reticulate)
#source_folder = "/Users/kaankeskin/projects/MYELIN_2/"
source_folder = "C:/Users/kaank/OneDrive/Belgeler/GitHub/MYELIN_2/"
use_python("C:/Users/kaank/miniconda3/envs/multgroup/python.exe")
#use_python("/opt/anaconda3/envs/neurolib_env/bin/python")
np <- import("numpy")
merge_matrices <- function(array) {
# Initialize empty matrices to store the merged results
merged_acw_static_firing_matrix <- NULL
merged_acw_dynamic_firing_matrix <- NULL
merged_gscorr_fmri_matrix <- NULL
merged_gscorr_firing_matrix <- NULL
# Loop through each element in the list and row bind the matrices
for (i in seq_along(array)) {
merged_acw_static_firing_matrix <- rbind(merged_acw_static_firing_matrix, array[[i]]$acw_static_firing_matrix)
merged_acw_dynamic_firing_matrix <- rbind(merged_acw_dynamic_firing_matrix, array[[i]]$acw_dynamic_firing_matrix)
merged_gscorr_fmri_matrix <- rbind(merged_gscorr_fmri_matrix, array[[i]]$gscorr_fmri_matrix)
merged_gscorr_firing_matrix <- rbind(merged_gscorr_firing_matrix, array[[i]]$gscorr_firing_matrix)
}
# Return a list of merged matrices
return(list(
acw_static_firing_matrix = merged_acw_static_firing_matrix,
acw_dynamic_firing_matrix = merged_acw_dynamic_firing_matrix,
gscorr_fmri_matrix = merged_gscorr_fmri_matrix,
gscorr_firing_matrix = merged_gscorr_firing_matrix
))
}
library(R.matlab)
library(NeuroMyelFC)
dat <- readMat(paste0(source_folder,"/DATA/7T_final.mat"))
dat_list <- list()
dat_list$myelin <- dat$myelin.replication
dat_list$ACW <- dat$ACW0.GS.replication
dat_list$GSCORR <- dat$GSCORR.GS.replication
level_list = list()
ylab_list = list()
parts=c("myelin", "ACW", "GSCORR")
level_list[[parts[1]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
level_list[[parts[2]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
level_list[[parts[3]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
ylab_list[[parts[1]]] = c("Myelin")
ylab_list[[parts[2]]] = c("ACW")
ylab_list[[parts[3]]] = c("GSCORR")
empirical <- calculate_prs(dat_list, parts = parts,levels=level_list,y_labels = ylab_list,textsize=6,sign_size=4,ast_size = 6,title = "", ylab_size= 12, method = "rowMeans")
ggpubr::ggarrange(plotlist = empirical$interaction_plots, nrow = 1, ncol = 3
)%>% ggpubr::ggexport(filename = paste0(source_folder,"FIGURES/empirical.png"),height = 400, width = 1200, res= 150)
library(tidyverse)
dat_list$myelin <- dat$myelin.replication
dat_list$ACW <- dat$ACW0.GS.replication
dat_list$GSCORR <- dat$GSCORR.GS.replication
level_list = list()
ylab_list = list()
parts=c("myelin", "ACW", "GSCORR")
level_list[[parts[1]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
level_list[[parts[2]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
level_list[[parts[3]]]=c("TransSelf","TransNonself","UniSelf" , "UniNonself")
ylab_list[[parts[1]]] = c("Myelin")
ylab_list[[parts[2]]] = c("ACW")
ylab_list[[parts[3]]] = c("GSCORR")
empirical <- calculate_prs(dat_list, parts = parts,levels=level_list,y_labels = ylab_list,textsize=6,sign_size=4,ast_size = 6,title = "", ylab_size= 12, method = "rowMeans")
ggpubr::ggarrange(plotlist = empirical$interaction_plots, nrow = 1, ncol = 3
)%>% ggpubr::ggexport(filename = paste0(source_folder,"FIGURES/empirical.png"),height = 400, width = 1200, res= 150)
source_folder = "/Users/kaankeskin/projects/MYELIN_2/"
# New figure with results
library(magick)
# Example PNG files
file3 <- paste0(source_folder,"FIGURES/empirical.png")
file4 <- paste0(source_folder,"FIGURES/recur_group_v3.png")
# Read the PNG files
image3 <- image_read(file3) %>% image_resize(geometry = "1200x")
source_folder = "C:/Users/kaank/OneDrive/Belgeler/GitHub/MYELIN_2/"
# New figure with results
library(magick)
# Example PNG files
file3 <- paste0(source_folder,"FIGURES/empirical.png")
file4 <- paste0(source_folder,"FIGURES/recur_group_v3.png")
# Read the PNG files
image3 <- image_read(file3) %>% image_resize(geometry = "1200x")
image4 <- image_read(file4) %>% image_resize(geometry = "1200x")
image_w <- image_blank(width=1200, height = 200, color = "white")
fig_5_merged <- image_append(c(image3,image_w, image4), stack = TRUE)
png(paste0(source_folder,"FIGURES/fig_5_new3.png"), width = 1200, height = 1400, res = 150)
plot(fig_5_merged)
text(x = 0, y = 1350, labels = "A", xpd = NA, cex=1.5, font=2)
text(x = 0, y = 750, labels = "B", xpd = NA, cex=1.5, font=2)
text(x = 550, y = 1400, labels = "Empirical Results", xpd = NA, cex=1.5, font=1)
text(x = 550, y = 850, labels = "Simulation Results", xpd = NA, cex=1.5, font=1)
text(x = 0, y = 400, labels = "C", xpd = NA, cex=1.5, font=2)
dev.off()
library(brms)
library(brms)
library(R.matlab)
library(tidyverse); library(reshape2)
#setwd("/Users/kaankeskin/projects/sch_pe/")
# Microsoft
setwd("C:/Users/kaank/OneDrive/Belgeler/GitHub/sch_pe/")
alpha_mat <- readMat("./results/models/alpha_matrix.mat")
alpha_mat
setwd("C:/Users/kaank/OneDrive/Belgeler/GitHub/sch_pe/")
#
dat <- list(readMat("./data/processed/normalized_pe_array2.mat"), # Cemre RW PE
readMat("./data/processed/x2_array.mat"), # HGF X2
readMat("./data/processed/x3_array.mat"), # HGF X3
readMat("./data/processed/x2_pe_array.mat"), # HGF low level PE
readMat("./data/processed/x3_pe_array.mat"), # HGF high level PE
readMat("./data/processed/alfa2_array.mat"), # learning rate level 2
readMat("./data/processed/alfa3_array.mat"), # learning rate level 3
readMat("./data/processed/rw_pe.mat") # RW model PE from TAPAS
)
subj_table <- read.csv("./data/raw/subjects_list.csv")
subj_table <- subset(subj_table, !(subj %in% c(9, 44)))
#dat <- readMat("/Users/kaankeskin/projects/sch_pe/data/processed/normalized_pe_array.mat")
dat[[1]]
dat[[1]]$merged.matrix
dat <- readMat("./data/processed/normalized_pe_array2.mat"
dat <- readMat("./data/processed/normalized_pe_array2.mat")
dat <- readMat("./data/processed/normalized_pe_array2.mat")
dat[,61]
dat$merged.matrix[,61]
convert_to_long <- function(data, group,subj_table, exclude=TRUE) {
# Extract PE matrix (first 60 columns) and group information (column 61)
if (exclude) data <- data[-c(9, 44), ]
pe_mat <- dat$merged.matrix[,1:60]
group <- group
task <- factor(rep(1:3, each = 20))  # Assuming 3 tasks with 20 trials each
sex <- factor(ifelse(subj_table$sex, "M", "F"))
age <- as.numeric(subj_table$age)
doi <- as.numeric(subj_table$DoI)
# Convert PE matrix to a data frame
pe_df <- as.data.frame(pe_mat)
# Add Subject IDs
pe_df$Subject <- seq_len(nrow(pe_mat))  # Assign unique IDs to subjects
# Reshape to long format
long_pe <- melt(pe_df, id.vars = "Subject", variable.name = "Trial", value.name = "PE")
# Convert Trial variable to numeric
#long_pe$Trial <- as.numeric(gsub("V", "", long_pe$Trial))  # Remove "V" prefix if needed
# Add Group information (repeat for each trial)
long_pe$Group <- rep(group, each = ncol(pe_mat))
# Add Task information (repeat for each subject)
long_pe$Task <- rep(task, times = nrow(pe_mat))
# Add Sex information (repeat for each trial)
long_pe$Sex <- rep(sex, each = ncol(pe_mat))
# Add Age information (repeat for each trial)
long_pe$Age <- rep(age, each = ncol(pe_mat))
# Add DoI information (repeat for each trial)
long_pe$DoI <- rep(doi, each = ncol(pe_mat))
return(long_pe)
}
dat
dat$merged.matrix[,61]
convert_to_long(alpha_mat, dat$merged.matrix[,61], subj_table, TRUE)
data
convert_to_long(alpha_mat, dat$merged.matrix[,61], subj_table, TRUE)
convert_to_long <- function(dat, group,subj_table, exclude=TRUE) {
# Extract PE matrix (first 60 columns) and group information (column 61)
if (exclude) dat <- dat[-c(9, 44), ]
pe_mat <- dat[,1:60]
group <- group
task <- factor(rep(1:3, each = 20))  # Assuming 3 tasks with 20 trials each
sex <- factor(ifelse(subj_table$sex, "M", "F"))
age <- as.numeric(subj_table$age)
doi <- as.numeric(subj_table$DoI)
# Convert PE matrix to a data frame
pe_df <- as.data.frame(pe_mat)
# Add Subject IDs
pe_df$Subject <- seq_len(nrow(pe_mat))  # Assign unique IDs to subjects
# Reshape to long format
long_pe <- melt(pe_df, id.vars = "Subject", variable.name = "Trial", value.name = "PE")
# Convert Trial variable to numeric
#long_pe$Trial <- as.numeric(gsub("V", "", long_pe$Trial))  # Remove "V" prefix if needed
# Add Group information (repeat for each trial)
long_pe$Group <- rep(group, each = ncol(pe_mat))
# Add Task information (repeat for each subject)
long_pe$Task <- rep(task, times = nrow(pe_mat))
# Add Sex information (repeat for each trial)
long_pe$Sex <- rep(sex, each = ncol(pe_mat))
# Add Age information (repeat for each trial)
long_pe$Age <- rep(age, each = ncol(pe_mat))
# Add DoI information (repeat for each trial)
long_pe$DoI <- rep(doi, each = ncol(pe_mat))
return(long_pe)
}
convert_to_long(alpha_mat, dat$merged.matrix[,61], subj_table, TRUE)
alpha_mat
convert_to_long(alpha_mat$alpha.matrix, dat$merged.matrix[,61], subj_table, TRUE)
convert_to_long(alpha_mat$alpha.matrix, dat$merged.matrix[-c(9, 44),61], subj_table, TRUE)
str(alpha_mat$alpha.matrix)
alpha_long <- convert_to_long(alpha_mat$alpha.matrix, dat$merged.matrix[-c(9, 44),61], subj_table, TRUE)
str(alpha_long)
any(alpha_long$PE==09)
any(alpha_long$PE==0)
any(alpha_long$PE==1)
fit <- brm(
formula = PE ~ Trial * Group + (1 + Trial | Subject),
family = family = gaussian(link = "logit"),
# Model fitting
fit <- brm(
formula = PE ~ Trial * Group + (1 + Trial | Subject),
family =  gaussian(link = "logit"),
data = alpha_long,
prior = c(
prior(normal(0, 1), class = "b"),
prior(cauchy(0, 1), class = "sd"),
prior(lkj(2), class = "cor")  # regularizing prior for random slopes
),
chains = 4,
cores = 4,
iter = 2000
)
str(alpha_long)
alpha_long$PE_logit <- qlogis(alpha_long$PE)  # qlogis = logit function
alpha_long$PE_logit
library(ggpubr)
ggdensity(alpha_long$PE_logit)
shapiro.test(alpha_long$PE_logit)
alpha_long <- convert_to_long(alpha_mat$alpha.matrix, dat$merged.matrix[-c(9, 44),61], subj_table, TRUE)
alpha_long$PE_logit <- qlogis(alpha_long$PE)  # qlogis = logit function
# Model fitting
fit <- brm(
formula = PE ~ Trial * Group + (1 + Trial | Subject),
family =  Beta(),
data = alpha_long,
prior = c(
prior(normal(0, 1), class = "b"),
prior(cauchy(0, 1), class = "sd"),
prior(lkj(2), class = "cor")  # regularizing prior for random slopes
),
chains = 4,
cores = 4,
iter = 2000
)
str(alpha_long)
any(alpha_long$PE==0)
any(alpha_long$PE==1)
View(alpha_long)
str(alpha_long)
> any(alpha_long$PE==0)
summary(alpha_long$PE)
sd(alpha_long$PE)
# Model fitting
fit <- brm(
formula = PE ~ Task * Group + (1 + Task | Subject),
family =  Beta(),
data = alpha_long,
prior = c(
prior(normal(0, 1), class = "b"),
prior(cauchy(0, 1), class = "sd"),
prior(lkj(2), class = "cor")  # regularizing prior for random slopes
),
chains = 4,
cores = 4,
iter = 2000
)
